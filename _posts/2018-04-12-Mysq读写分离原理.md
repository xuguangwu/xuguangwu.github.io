---
title: mysql读写分离原理
categories:
 - mysql
tags: 
 - mysql
---

## 如何实现读写分离
一主多从，主提供写，从提供读。

## 原理
主库将变更写入 binlog 日志，然后从库连接到主库之后，
从库有一个 IO 线程，将主库的 binlog 日志拷贝到自己本地，
写入一个 relay 中继日志中。
接着从库中有一个 SQL 线程会从中继日志读取 binlog，然后执行 binlog 日志中的内容，
也就是在自己本地再次执行一遍 SQL，这样就可以保证自己跟主库的数据是一样的。

![slf4j-bridge](https://raw.githubusercontent.com/xuguangwu/xuguangwu.github.io/master/img/in-post/mysql/mysql-master-slave.png)


由于从库从主库拷贝日志以及串行执行 SQL 的特点，
在高并发场景下，从库的数据一定会比主库慢一些，是有延时的。
所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能读取到。

同时也会面临数据丢失的问题，主库宕机，而从库还未同步。
所以 MySQL 实际上在这一块有两个机制，
一个是半同步复制，用来解决主库数据丢失问题；一个是并行复制，用来解决主从同步延时问题。

这个所谓半同步复制，也叫 semi-sync 复制，
指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，
从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，
主库接收到至少一个从库的 ack 之后才会认为写操作完成了。

所谓并行复制，指的是从库开启多个线程，并行读取 relay log 中不同库的日志，
然后并行重放不同库的日志，这是库级别的并行。

## 主从同步延时问题
可能会有这样的场景，插入之后就要更新，在非主从同步的架构上，可以在插入之后，然后查询，接着再去更新，
但是主从同步延时，导致插入之后，查询为空，那么更新就会失败。
所以在这种场景下，插入成功，无需再去查询，直接更新就可以避免延时问题了。






