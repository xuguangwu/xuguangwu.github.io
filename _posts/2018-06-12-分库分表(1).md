---
title: 分库分表(1)
categories:
 - Java
tags:
 - Java,SQL
---

分库分表，我想到的第一个问题是，用uid分库，uname上的怎么快速查询。
在网上搜罗了一圈，找到以下一些策略，mark一下。

## 索引表法
#### 思路：
uid能直接定位到库，uname不能直接定位到库，如果通过uname能查询到uid，问题解决
#### 解决方案：
建立一个索引表记录uname->uid的映射关系
用uname来访问时，先通过索引表查询到uid，再定位相应的库。
这里可以用缓存也可以直接存储db，看数据量。
因为索引表属性较少，可以容纳非常多数据，一般不需要分库
#### 潜在不足：
多查询db或者cache，性能下降

## uname生成uid
#### 思路：
不进行远程查询，由uname直接得到uid
#### 解决方案：
在用户注册时，设计函数uname生成uid，uid=f(uname)，按uid分库插入数据
用uname来访问时，先通过函数计算出uid，即uid=f(uname)再来一遍，由uid路由到对应库
#### 潜在不足：
该函数设计需要非常讲究技巧，有uid生成冲突风险

## 基因法(uname基因融入uid)
#### 思路：
不能用uname生成uid，可以从uname抽取“基因”，融入uid中
假设分8库，采用uid%8路由，潜台词是，uid的最后3个bit决定这条数据落在哪个库上，这3个bit就是所谓的“基因”

#### 解决方案：
在用户注册时，设计函数uname生成3bit基因，uname_gene=f(uname)，如上图粉色部分
同时，生成61bit的全局唯一id，作为用户的标识，如上图绿色部分
接着把3bit的uname_gene也作为uid的一部分，如上图屎黄色部分
生成64bit的uid，由id和uname_gene拼装而成，并按照uid分库插入数据
用uname来访问时，先通过函数由uname再次复原3bit基因，uname_gene=f(uname)，通过uname_gene%8直接定位到库
