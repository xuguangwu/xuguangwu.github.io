---
title: 垃圾回收机制
categories:
 - Java
tags: JVM
---

简单的记录下对象存活(可达分析算法)流程：
1.枚举根节点：在该过程中会出现stop the world。
这是因为在该过程中必须保证jvm中的对象引用关系不会发生变化，
这就导致了必须停顿所有的java线程。

2.准确式GC：当执行系统停顿后，通过OopMap的数据结构来得知哪些地方存放对象引用。

3.安全点(SafePoint)：主动式中断所有线程(不包括JNI线程)，设置一个中断标志，各个线程执行时主动
轮询该标志，发现中断时就自己中断挂起。轮询标志的地方与安全点重合。
安全点不能太少，gc等待时间太长。也不能太多，增大运行负荷。
(这里看书的时候可能不太明白，我讲述下自己的理解：程序并非在任何时候都能停顿下来发生gc，只能到达了安全点
才能stop the world。程序中线程通过该安全点的时候会对象引用关系保存到OopMap中，这样jvm就不会耗费更多的
空间和性能去做垃圾回收)

4.安全区域(SafeRegion)：线程执行SafeRegion中的代码，会先添加SafeRegion标识，在之后这段时间里jvm发起的gc，不用管标识自己为
SafeRegion状态的线程了，在线程要离开SafeRegion的时候检查gc是否完成，完成了线程继续，否则等待离开信号。

额外提一下方法区(永久代)的gc。
方法区主要回收废弃常量和无用的类。
常量与回收对象的方式差不多，在常量池中没有对象引用的常量会被回收。
无用的类需要满足三个条件：
1.堆中不存在该类的实例
2.该类的Classloader已经被回收
3.该类对应的java.lang.Class对象没有任何对象引用，无法通过反射访问该类的方法。


