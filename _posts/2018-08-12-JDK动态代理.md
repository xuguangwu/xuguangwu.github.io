---
title: JDK动态代理
categories:
 - java
tags: 
 - java
---

代理的目标对象
````
public class TestServiceImpl implements TestService {

    @Override
    public void testA() {
        testB();
        //解决方案1：从Aop上下文获取当前的代理对象
        TestService testService = (TestService) AopContext.currentProxy();

        System.out.println("aaaa");
    }

    @Override
    public void testB() {
        System.out.println("bbbbb");
    }
}
````

service接口
````
public interface TestService {

    void testA();

    void testB();
    
}
````

之前一直有一个疑问，为什么一定要单独有个service接口，知道发现了代理实例化
目标对象的时候传参为接口，就明白了一切。

````
public class MyInvocationHandler implements InvocationHandler {

    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //TODO 额外的处理
        System.out.println("代理中的方法");
        return method.invoke(target, args);//实际上调用目标对象的方法
    }

    public static void main(String[] args) {
        MyInvocationHandler myInvocationHandler = new MyInvocationHandler(new TestServiceImpl());

        TestService proxy = (TestService) Proxy.newProxyInstance(MyInvocationHandler.class.getClassLoader(), new Class[]{TestService.class}, myInvocationHandler);

        proxy.testA();
//        proxy.testB();
    }
}
````



